---
title: "Access_Index_Functions"
author: "Andrew Taylor"
date: "7/23/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Intro
This markdown defines functions for use in calculating an access index per user specifications on filtering reschool program data. Additionally, this markdown provides leaflet code for plotting the results of the index by census block group. This markdown reads census_centroids as a shapefile from my machine, as we haven't pushed this to the RDS yet. 

###RDS Pull
```{r}
library(rgeos)
library(rgdal)
library(raster)
library(tidyverse)
library(RPostgreSQL)
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")

# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv, dbname = "dssg2018uw",
                 host = "localhost", port = 9000,
                 user = user, password = password) #local source credentials

#get reschool_programs
reschool_programs <- dbGetQuery(con, "select * from clean.reschool_summer_programs")

#disconnect
dbDisconnect(con) 
dbUnloadDriver(drv)
```

###Establishing Cost Thresholds and Umbrella Program Types
```{r}
reschool_programs$academic <- ifelse(reschool_programs$has_academic==TRUE | reschool_programs$has_stem==TRUE,TRUE,FALSE) 

reschool_programs$art <- ifelse(reschool_programs$has_arts==TRUE | reschool_programs$has_cooking==TRUE | 
                                  reschool_programs$has_dance==TRUE | reschool_programs$has_drama==TRUE
                                | reschool_programs$has_music==TRUE,
                                TRUE,FALSE)

#cost thresolds, to be updated w/ time data from selam
reschool_programs$free <- ifelse(reschool_programs$session_cost==0,TRUE,FALSE)
reschool_programs$lowcost <- ifelse(reschool_programs$session_cost<=50,TRUE,FALSE)
reschool_programs$highcost <- ifelse(reschool_programs$session_cost>50,TRUE,FALSE)
```


###Functions for Flexible Access Index Calculation
```{r}
type <- c("academic","art") #needs to be a vector of whatever get's passed to shiny

Make_Subset <- function(dataframe,type=NULL,cost=NULL){
  if(is.null(type)){
    dataframe <- dataframe
    }
  if(length(type)==1){
    dataframe <- dataframe[dataframe[,type],]
  }
  if(length(type)>1){
    dataframe <- dataframe[apply(FUN=any,X=dataframe[,c(type)],MARGIN=1),]
  }
  if(is.null(cost)){
    return(dataframe)
  }
  else{
     dataframe <- dataframe <- dataframe[dataframe[,cost],]
  }
}


Aggregate_Subset <- function(dataframe){
  return(aggregate(n ~ session_address_1+lat+long, data=dataframe,FUN=sum))
}

Merge_Set <- function(dataframe){
  block_distance_new <- block_distance[,-c(3,4,9:14)]
  temp <- merge(block_distance_new,dataframe,all.y=TRUE)
  temp$n[is.na(temp$n)==TRUE] <- 0
  return(temp)
}

decay_fxn <- function(dataframe,mode){
  if (mode=="transit") {
    scale = 5
    column="transit_morning"
  }
  if (mode=="drive"){
    scale = 5
    column="driving_morning"
  }
  mode=mode
  dataframe[,"n"]*(ifelse(dataframe[,column]<=scale,1,(1/(dataframe[,column]/scale))^2))
}


normalize <- function(vec,max) {
  return(vec/max)
}
```

###Get total access index
This is critical to establishing a range to normalize all subset values across, as well as establishing a uniform numeric color pallete. 
```{r}
library(scales)
#User specifies query (type)

#subset dataframe by user selection
user_set <- reschool_programs

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#calculate access index per location 
merged_set$transit_morning[is.na(merged_set$transit_morning)] <- merged_set$walking_morning[is.na(merged_set$transit_morning)]
merged_set$transit_morning[merged_set$transit_morning==0] <- merged_set$walking_morning[merged_set$transit_morning==0]

merged_set$CarAccessIndex <- decay_fxn(merged_set,"drive") 
merged_set$TransitAccessIndex <- decay_fxn(merged_set,"transit") 


#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_total <- aggregate(CarAccessIndex ~ Id2,data=merged_set,FUN=sum)
max_access <- max(summary_index_total$CarAccessIndex)
summary_index_total$CarAccessIndex <- normalize(summary_index_total$CarAccessIndex,max_access)
```

###User Script for Driving
This is the exact script to use to query, for an example type.
```{r}
library(scales)
#User specifies query (type)
#type <- c("art") #"type" can include categories or cost thresholds. Pending cost per day calculations from Selam
#cost <- c("free")
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#calculate access index per location 
merged_set$AccessIndex <- decay_fxn(merged_set,"drive") #why not apply? who knows

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_user <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum) #critical that we use sum, not mean, BECAUSE, for some specifications some program lengths will drop

#normalize
summary_index_user$AccessIndex <- normalize(summary_index_user$AccessIndex,max_access) 
```

###User Script for Transit
```{r}
library(scales)
#User specifies query (type)
#type <- c("has_sports","art")
type <- NULL #to use all
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#replace na and 0 transit times with drive times
merged_set$transit_morning[is.na(merged_set$transit_morning)] <- merged_set$walking_morning[is.na(merged_set$transit_morning)]
merged_set$transit_morning[merged_set$transit_morning==0] <- merged_set$walking_morning[merged_set$transit_morning==0]

#calculate access index per location, #get average of AccessIndex col, return to summary dataframe by blockgroup ID
system.time(merged_set$AccessIndex <- decay_fxn(merged_set,"transit"))
system.time(summary_index_user_transit <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum))

#normalize
summary_index_user_transit$AccessIndex <- normalize(summary_index_user_transit$AccessIndex,max_access)
```

###Plot Driving Summary Index
```{r}
library(leaflet)
library(RColorBrewer)

#Ordering
census_blocks$Id2 <- as.numeric(census_blocks$Id2)
merged_set$Id2 <- as.numeric(merged_set$Id2)
summary_index_user$Id2 <- as.numeric(summary_index_user$Id2)

census_blocks <- census_blocks[order(census_blocks$Id2),]
merged_set <- merged_set[order(merged_set$Id2),]
summary_index_user <- summary_index_user[order(summary_index_user$Id2),] 

#specifiying color pallet
colourCount <- length(unique(agg_set$n))
getPalette <- colorRampPalette(brewer.pal(9,"Reds"))

pal <- colorNumeric(
  palette = "Blues",
  domain =  0:1)

pal2 <- colorNumeric(
  palette = rev(getPalette(colourCount)),
  domain = range(agg_set$n))

#indicating one popup info
info <- paste("n",agg_set$n)

#creating leaflet map
Ai_driving <- leaflet(census_blocks) %>%
  addTiles() %>%
  addPolygons(color = "Blues",weight =1,smoothFactor = 0.5,opacity = 0.5,fillOpacity = 0.75,
              fillColor = ~pal(summary_index_user$AccessIndex),
              popup=paste(as.numeric(summary_index_user$Id2),summary_index_user$AccessIndex,as.numeric(census_blocks$Id2)),
              highlightOptions = highlightOptions(color = "white", weight = 0.1)) %>%
  
  addLegend(pal = pal, values = ~summary_index_user$AccessIndex, opacity = 1,title = "Driving AI Score") %>%
  
  addCircles(data = agg_set, 
             opacity = 1,weight=7, popup=info,
             color = ~pal2(agg_set$n) ) %>%
  
  setView(lat=39.7,lng=-104.9,zoom=11.5)
```

###Plot Transit Index
```{r}
library(leaflet)
library(RColorBrewer)

#Ordering
census_blocks$Id2 <- as.numeric(census_blocks$Id2)
merged_set$Id2 <- as.numeric(merged_set$Id2)
summary_index_user_transit$Id2 <- as.numeric(summary_index_user_transit$Id2)

census_blocks <- census_blocks[order(census_blocks$Id2),]
merged_set <- merged_set[order(merged_set$Id2),]
summary_index_user_transit <- summary_index_user_transit[order(summary_index_user_transit$Id2),] 

#specifiying color pallet
colourCount <- length(unique(agg_set$n))
getPalette <- colorRampPalette(brewer.pal(9,"Reds"))

pal <- colorNumeric(
  palette = "Blues",
  domain =  0:1)

pal2 <- colorNumeric(
  palette = rev(getPalette(colourCount)),
  domain = range(agg_set$n))

#indicating one popup info
info <- paste("n",agg_set$n)

#creating leaflet map
Ai_transit <- leaflet(census_blocks) %>%
  addTiles() %>%
  addPolygons(color = "Blues",weight =1,smoothFactor = 0.5,opacity = 0.5,fillOpacity = 0.75,
              fillColor = ~pal(summary_index_user_transit$AccessIndex),
              popup=paste(as.numeric(summary_index_user_transit$Id2),summary_index_user_transit$AccessIndex,as.numeric(census_blocks$Id2)),
              highlightOptions = highlightOptions(color = "white", weight = 0.1)) %>%
  
  addLegend(pal = pal, values = ~summary_index_user_transit$AccessIndex, opacity = 1,title = "Transit AI Score") %>%
  
  addCircles(data = agg_set, 
             opacity = 1,weight=7, popup=info,
             color = ~pal2(agg_set$n) ) %>%
  
  setView(lat=39.7,lng=-104.9,zoom=11.5)
```

###Diff between transit and driving
Here we check the difference between them. This is a validation test, as per the specification we're using, where both transit and driving use the same decay function with the same scale, transit should always be lower than driving, particularly in places with lots of quick access to multiple programs. 
```{r}
library(leaflet)
library(RColorBrewer)

#Ordering
census_blocks$Id2 <- as.numeric(census_blocks$Id2)
merged_set$Id2 <- as.numeric(merged_set$Id2)
summary_index_user_transit$Id2 <- as.numeric(summary_index_user_transit$Id2)

census_blocks <- census_blocks[order(census_blocks$Id2),]
merged_set <- merged_set[order(merged_set$Id2),]
summary_index_user <- summary_index_user[order(summary_index_user$Id2),] 

summary_index_user$dif <- summary_index_user$AccessIndex - summary_index_user_transit$AccessIndex

#specifiying color pallet
colourCount <- length(unique(agg_set$n))
getPalette <- colorRampPalette(brewer.pal(9,"Reds"))

pal <- colorNumeric(
  palette = "Blues",
  domain =  summary_index_total$dif)

pal2 <- colorNumeric(
  palette = rev(getPalette(colourCount)),
  domain = range(agg_set$n))

#indicating one popup info
info <- paste("n",agg_set$n)

#creating leaflet map
Ai_leaflet_dif <- leaflet(census_blocks) %>%
  addTiles() %>%
  addPolygons(color = "Blues",weight =1,smoothFactor = 0.5,opacity = 0.5,fillOpacity = 0.75,
              fillColor = ~pal(summary_index_user$dif),
              popup=paste(as.numeric(summary_index_user$Id2),summary_index_user$dif,as.numeric(census_blocks$Id2)),
              highlightOptions = highlightOptions(color = "white", weight = 0.1)) %>%
  
  addLegend(pal = pal, values = ~summary_index_user$dif, opacity = 1,title = "Dif in Access Index Score") %>%
  
  addCircles(data = agg_set, 
             opacity = 1,weight=7, popup=info,
             color = ~pal2(agg_set$n) ) %>%
  
  setView(lat=39.7,lng=-104.9,zoom=11.5)
```

###Sensitivity Analysis Driving Test
Because we are to some extent selecting an arbitrary indifference threshold of five minutes, it is critical that we assess how sensitive our conclusions are to threshold. So here we test different indifference thresholds and see how the order of top block groups changes. Basically, we scale up the threshold from 5 five minutes to 15 minutes, checking changes in the order of the block groups at each minute threshold. 
```{r}
#run overall access index driving
library(scales)
#User specifies query (type)
#type <- c("art") #"type" can include categories or cost thresholds. Pending cost per day calculations from Selam
#cost <- c("free")
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#calculate access index per location 
merged_set$AccessIndex <- decay_fxn(merged_set,"drive") #why not apply? who knows

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_user <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum) #critical that we use sum, not mean, BECAUSE, for some specifications some program lengths will drop

#make base dataframe
summary_index_user <- summary_index_user[order(summary_index_user$AccessIndex),]
rownames(summary_index_user)  <- NULL
summary_index_user$base_rank <- rownames(summary_index_user)

for (i in 1:9){
#generate overall
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#alter decay function
decay_fxn_sensitive <- function(dataframe,mode){
  if (mode=="transit") {
    scale = 5+i
    column="transit_morning"
  }
  if (mode=="drive"){
    scale = 5+i
    column="driving_morning"
  }
  mode=mode
  dataframe[,"n"]*(ifelse(dataframe[,column]<=scale,1,(1/(dataframe[,column]/scale))^2))
}

#apply decay function
merged_set$AccessIndex <- decay_fxn_sensitive(merged_set,"drive")

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_mover <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum)

#order
summary_index_mover <- summary_index_mover[order(summary_index_mover$AccessIndex),]

#prep for merge
rownames(summary_index_mover) <- NULL
summary_index_mover$rank.i <- rownames(summary_index_mover)
colnames(summary_index_mover)[colnames(summary_index_mover)=="rank.i"] <- paste("rank",i)

#print summary of AI for validation on if this is working
print(summary(summary_index_mover$AccessIndex))
summary_index_mover$AccessIndex <- NULL

#merge new data to dataframe
summary_index_user <- merge(summary_index_user,summary_index_mover,by="Id2",all.y=TRUE)
print(paste(i,"iteration..."))
}

#store as a new data frame
sensitivity_frame <- summary_index_user 

#get the total changes in rank from threshold of five minutes to 16 minutes
sensitivity_frame$changes <- abs(as.numeric(sensitivity_frame$base_rank) - as.numeric(sensitivity_frame$`rank 9`))
```

###Plot driving changes in rank
```{r}
library(reshape2)
library(ggplot2)
library(gridExtra)
#Prep & order frame
sensitivity_frame <- summary_index_user 
sensitivity_frame$base_rank <- as.numeric(sensitivity_frame$base_rank)
sensitivity_frame <- sensitivity_frame[order(sensitivity_frame$base_rank),]

#subsetframe
top_25 <- sensitivity_frame[1:25,]
sa_25_50 <- sensitivity_frame[1:50,]
sa_50_75 <- sensitivity_frame[1:75,]
sa_75_100 <- sensitivity_frame[1:100,]
sa_tail <- sensitivity_frame[456:481,]
sa_tailstart <- sensitivity_frame[406:481,]


#Top 25 Plot
df <- melt(top_25,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_Top_25_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 25") + ylim(1,490)

#Top 50 Plot
df <- melt(sa_25_50,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_Top_50_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 50") + ylim(1,490)

#Top 75 Plot
df <- melt(sa_50_75,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_Top_75_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 75") + ylim(1,490)

#Top 100 Plot
df <- melt(sa_75_100,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_Top_100_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 100") + ylim(1,490)

#Bottom 50
df <- melt(sa_tail,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_Tail_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="Bottom 50") + ylim(1,490)

#Bottom 25
df <- melt(sa_tailstart,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_Bottom25_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="Bottom 100") + ylim(1,490)

grid.arrange(driving_Top_25_Plot,driving_Top_50_Plot,driving_Top_75_Plot,driving_Top_100_Plot,driving_Bottom25_Plot,driving_Tail_Plot,ncol=3)
```

###Redo with transit
```{r}
#run overall access index driving
library(scales)
#User specifies query (type)
#type <- c("art") #"type" can include categories or cost thresholds. Pending cost per day calculations from Selam
#cost <- c("free")
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#calculate access index per location 
merged_set$AccessIndex <- decay_fxn(merged_set,"transit") #why not apply? who knows

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_user <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum) #critical that we use sum, not mean, BECAUSE, for some specifications some program lengths will drop

#make base dataframe
summary_index_user <- summary_index_user[order(summary_index_user$AccessIndex),]
rownames(summary_index_user)  <- NULL
summary_index_user$base_rank <- rownames(summary_index_user)

for (i in 1:9){
#generate overall
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#alter decay function
decay_fxn_sensitive <- function(dataframe,mode){
  if (mode=="transit") {
    scale = 5+i
    column="transit_morning"
  }
  if (mode=="drive"){
    scale = 5+i
    column="driving_morning"
  }
  mode=mode
  dataframe[,"n"]*(ifelse(dataframe[,column]<=scale,1,(1/(dataframe[,column]/scale))^2))
}

#apply decay function
merged_set$AccessIndex <- decay_fxn_sensitive(merged_set,"transit")

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_mover <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum)

#order
summary_index_mover <- summary_index_mover[order(summary_index_mover$AccessIndex),]

#prep for merge
rownames(summary_index_mover) <- NULL
summary_index_mover$rank.i <- rownames(summary_index_mover)
colnames(summary_index_mover)[colnames(summary_index_mover)=="rank.i"] <- paste("rank",i)

#print summary of AI for validation on if this is working
print(summary(summary_index_mover$AccessIndex))
summary_index_mover$AccessIndex <- NULL

#merge new data to dataframe
summary_index_user <- merge(summary_index_user,summary_index_mover,by="Id2",all.y=TRUE)
print(paste(i,"iteration..."))
}

#store as a new data frame
sensitivity_frame_transit <- summary_index_user 

#get the total changes in rank from threshold of five minutes to 16 minutes
sensitivity_frame_transit$changes <- abs(as.numeric(sensitivity_frame_transit$base_rank) - as.numeric(sensitivity_frame_transit$`rank 9`))
```

###Plot transit changes in rank
```{r}
library(reshape2)
library(ggplot2)
library(gridExtra)
#Prep & order frame
sensitivity_frame_transit <- sensitivity_frame_transit 
sensitivity_frame_transit$base_rank <- as.numeric(sensitivity_frame_transit$base_rank)
sensitivity_frame_transit <- sensitivity_frame_transit[order(sensitivity_frame_transit$base_rank),]

#subsetframe
top_25 <- sensitivity_frame_transit[1:25,]
sa_25_50 <- sensitivity_frame_transit[1:50,]
sa_50_75 <- sensitivity_frame_transit[1:75,]
sa_75_100 <- sensitivity_frame_transit[1:100,]
sa_tail <- sensitivity_frame_transit[456:480,]
sa_tailstart <- sensitivity_frame_transit[406:480,]


#Top 25 Plot
df <- melt(top_25,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

Top_25_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 25") + ylim(1,490)

#Top 50 Plot
df <- melt(sa_25_50,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

Top_50_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 50") + ylim(1,490)

#Top 75 Plot
df <- melt(sa_50_75,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

Top_75_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 75") + ylim(1,490)

#Top 100 Plot
df <- melt(sa_75_100,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

Top_100_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 100") + ylim(1,490)

#Bottom 50
df <- melt(sa_tail,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

Tail_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="Bottom 50") + ylim(1,490)

#Bottom 25
df <- melt(sa_tailstart,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

Bottom25_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="Bottom 100") + ylim(1,490)

grid.arrange(Top_25_Plot,Top_50_Plot,Top_75_Plot,Top_100_Plot,Bottom25_Plot,Tail_Plot,ncol=3)
```

###Driving Exp Function
```{r}
#run overall access index driving
library(scales)
#User specifies query (type)
#type <- c("art") #"type" can include categories or cost thresholds. Pending cost per day calculations from Selam
#cost <- c("free")
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#calculate access index per location 
i <- 0
merged_set$AccessIndex <- decay_fxn_exp_sensitive(merged_set,"drive") #why not apply? who knows

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_user <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum) #critical that we use sum, not mean, BECAUSE, for some specifications some program lengths will drop

#make base dataframe
summary_index_user <- summary_index_user[order(summary_index_user$AccessIndex),]
rownames(summary_index_user)  <- NULL
summary_index_user$base_rank <- rownames(summary_index_user)

for (i in 1:9){
#generate overall
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#alter decay function
decay_fxn_exp_sensitive <- function(dataframe,mode){
  if (mode=="transit") {
    scale = 5+i
    column="transit_morning"
  }
  if (mode=="drive"){
    scale = 5+i
    column="driving_morning"
  }
  mode=mode
  dataframe[,"n"]*exp(-dataframe[,column]/scale)
}

#apply decay function
merged_set$AccessIndex <- decay_fxn_exp_sensitive(merged_set,"drive")

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_mover <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum)

#order
summary_index_mover <- summary_index_mover[order(summary_index_mover$AccessIndex),]

#prep for merge
rownames(summary_index_mover) <- NULL
summary_index_mover$rank.i <- rownames(summary_index_mover)
colnames(summary_index_mover)[colnames(summary_index_mover)=="rank.i"] <- paste("rank",i)

#print summary of AI for validation on if this is working
print(summary(summary_index_mover$AccessIndex))
summary_index_mover$AccessIndex <- NULL

#merge new data to dataframe
summary_index_user <- merge(summary_index_user,summary_index_mover,by="Id2",all.y=TRUE)
print(paste(i,"iteration..."))
}

#store as a new data frame
sensitivity_frame_exp <- summary_index_user 

#get the total changes in rank from threshold of five minutes to 16 minutes
sensitivity_frame_exp$changes <- abs(as.numeric(sensitivity_frame_exp$base_rank) - as.numeric(sensitivity_frame_exp$`rank 9`))
```

###Plot Exp 
```{r}
library(reshape2)
library(ggplot2)
library(gridExtra)
#Prep & order frame
sensitivity_frame_exp <- sensitivity_frame_exp 
sensitivity_frame_exp$base_rank <- as.numeric(sensitivity_frame_exp$base_rank)
sensitivity_frame_exp <- sensitivity_frame_exp[order(sensitivity_frame_exp$base_rank),]

#subsetframe
top_25 <- sensitivity_frame_exp[1:25,]
sa_25_50 <- sensitivity_frame_exp[1:50,]
sa_50_75 <- sensitivity_frame_exp[1:75,]
sa_75_100 <- sensitivity_frame_exp[1:100,]
sa_tail <- sensitivity_frame_exp[456:480,]
sa_tailstart <- sensitivity_frame_exp[406:480,]


#Top 25 Plot
df <- melt(top_25,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_exp_Top_25_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 25") + ylim(1,490)

#Top 50 Plot
df <- melt(sa_25_50,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_exp_Top_50_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 50") + ylim(1,490)

#Top 75 Plot
df <- melt(sa_50_75,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_exp_Top_75_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 75") + ylim(1,490)

#Top 100 Plot
df <- melt(sa_75_100,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_exp_Top_100_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 100") + ylim(1,490)

#Bottom 50
df <- melt(sa_tail,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_exp_Tail_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="Bottom 50") + ylim(1,490)

#Bottom 25
df <- melt(sa_tailstart,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_exp_Bottom25_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="Bottom 100") + ylim(1,490)

grid.arrange(driving_exp_Top_25_Plot,driving_exp_Top_50_Plot,driving_exp_Top_75_Plot,driving_exp_Top_100_Plot,driving_exp_Bottom25_Plot,driving_exp_Tail_Plot,ncol=3)
```

###Compare Exp and Base
1.) Make time series plot comparing dif ranks between exp and base 
2.) Start w/ base scale =5 
2.) Make like 9-10 plots, each a dif scale, comparing
```{r}

```


###Gravity Model
At the end of the day, scale in this case in a constant. However, it's fucked for dealing with close proximity tons.
```{r}
#run overall access index driving
library(scales)
#User specifies query (type)
#type <- c("art") #"type" can include categories or cost thresholds. Pending cost per day calculations from Selam
#cost <- c("free")
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#calculate access index per location 
i <- 0
merged_set$AccessIndex <- decay_fxn_sensitive_gravity(merged_set,"drive") #why not apply? who knows

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_user <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum) #critical that we use sum, not mean, BECAUSE, for some specifications some program lengths will drop

#make base dataframe
summary_index_user <- summary_index_user[order(summary_index_user$AccessIndex),]
rownames(summary_index_user)  <- NULL
summary_index_user$base_rank <- rownames(summary_index_user)

for (i in 1:9){
#generate overall
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#alter decay function
decay_fxn_sensitive_gravity <- function(dataframe,mode){
  if (mode=="transit") {
    scale = 5+i
    column="transit_morning"
  }
  if (mode=="drive"){
    scale = 5+i
    column="driving_morning"
  }
  mode=mode
  dataframe[,"n"]*((1/(dataframe[,column]/scale))^2)
}

#apply decay function
merged_set$AccessIndex <- decay_fxn_sensitive_gravity(merged_set,"drive")

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_mover <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum)

#order
summary_index_mover <- summary_index_mover[order(summary_index_mover$AccessIndex),]

#prep for merge
rownames(summary_index_mover) <- NULL
summary_index_mover$rank.i <- rownames(summary_index_mover)
colnames(summary_index_mover)[colnames(summary_index_mover)=="rank.i"] <- paste("rank",i)

#print summary of AI for validation on if this is working
print(summary(summary_index_mover$AccessIndex))
summary_index_mover$AccessIndex <- NULL

#merge new data to dataframe
summary_index_user <- merge(summary_index_user,summary_index_mover,by="Id2",all.y=TRUE)
print(paste(i,"iteration..."))
}

#store as a new data frame
sensitivity_frame_gravity <- summary_index_user 

#get the total changes in rank from threshold of five minutes to 16 minutes
sensitivity_frame_gravity$changes <- abs(as.numeric(sensitivity_frame_gravity$base_rank) - as.numeric(sensitivity_frame_gravity$`rank 9`))
```

###Plot Gravity
```{r}
library(reshape2)
library(ggplot2)
library(gridExtra)
#Prep & order frame
sensitivity_frame_gravity <- sensitivity_frame_gravity 
sensitivity_frame_gravity$base_rank <- as.numeric(sensitivity_frame_gravity$base_rank)
sensitivity_frame_gravity <- sensitivity_frame_gravity[order(sensitivity_frame_gravity$base_rank),]

#subsetframe
top_25 <- sensitivity_frame_gravity[1:25,]
sa_25_50 <- sensitivity_frame_gravity[1:50,]
sa_50_75 <- sensitivity_frame_gravity[1:75,]
sa_75_100 <- sensitivity_frame_gravity[1:100,]
sa_tail <- sensitivity_frame_gravity[456:480,]
sa_tailstart <- sensitivity_frame_gravity[406:480,]


#Top 25 Plot
df <- melt(top_25,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_gravity_Top_25_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 25") + ylim(1,490)

#Top 50 Plot
df <- melt(sa_25_50,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_gravity_Top_50_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 50") + ylim(1,490)

#Top 75 Plot
df <- melt(sa_50_75,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_gravity_Top_75_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 75") + ylim(1,490)

#Top 100 Plot
df <- melt(sa_75_100,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_gravity_Top_100_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="top 100") + ylim(1,490)

#Bottom 50
df <- melt(sa_tail,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_gravity_Tail_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="Bottom 50") + ylim(1,490)

#Bottom 25
df <- melt(sa_tailstart,id=c("Id2","AccessIndex"),measure.vars=c("base_rank","rank 1","rank 2","rank 3","rank 4","rank 5","rank 6","rank 7","rank 8","rank 9"))
df$value <- as.numeric(df$value)
df$variable <- as.factor(df$variable)

driving_gravity_Bottom25_Plot <- ggplot(df, aes(variable,value,group = Id2, color = as.factor(Id2))) + geom_line() + theme(legend.position="none") + labs(title="Bottom 100") + ylim(1,490)

grid.arrange(driving_gravity_Top_25_Plot,driving_gravity_Top_50_Plot,driving_gravity_Top_75_Plot,driving_gravity_Top_100_Plot,driving_gravity_Bottom25_Plot,driving_gravity_Tail_Plot,ncol=3)
```

###Plot Gravity Blocks
```{r}
library(leaflet)
library(RColorBrewer)
test <- sensitivity_frame_gravity
test$AccessIndex <- normalize(test$AccessIndex,max = max(test$AccessIndex))
test$Id2 <- as.numeric(test$Id2)
test <- test[order(test$Id2),]

#Ordering
census_blocks$Id2 <- as.numeric(census_blocks$Id2)
merged_set$Id2 <- as.numeric(merged_set$Id2)
summary_index_user$Id2 <- as.numeric(summary_index_user$Id2)

census_blocks <- census_blocks[order(census_blocks$Id2),]
merged_set <- merged_set[order(merged_set$Id2),]
summary_index_user <- summary_index_user[order(summary_index_user$Id2),] 

#specifiying color pallet
colourCount <- length(unique(agg_set$n))
getPalette <- colorRampPalette(brewer.pal(9,"Reds"))

pal <- colorNumeric(
  palette = "Blues",
  domain =  0:1)

pal2 <- colorNumeric(
  palette = rev(getPalette(colourCount)),
  domain = range(agg_set$n))

#indicating one popup info
info <- paste("n",agg_set$n)

#creating leaflet map
Ai_driving_gravity <- leaflet(census_blocks) %>%
  addTiles() %>%
  addPolygons(color = "Blues",weight =1,smoothFactor = 0.5,opacity = 0.5,fillOpacity = 0.75,
              fillColor = ~pal(test$AccessIndex),
              popup=paste(as.numeric(summary_index_user$Id2),as.numeric(test$AccessIndex),as.numeric(census_blocks$Id2)),
              highlightOptions = highlightOptions(color = "white", weight = 0.1)) %>%
  
  addLegend(pal = pal, values = ~test$AccessIndex, opacity = 1,title = "Driving Gravity AI Score") %>%
  
  addCircles(data = agg_set, 
             opacity = 1,weight=7, popup=info,
             color = ~pal2(agg_set$n) ) %>%
  
  setView(lat=39.7,lng=-104.9,zoom=11.5)
```

