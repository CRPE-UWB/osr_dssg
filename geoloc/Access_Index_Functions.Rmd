---
title: "Access_Index_Functions"
author: "Andrew Taylor"
date: "7/23/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Intro
This markdown defines functions for use in calculating an access index per user specifications on filtering reschool program data. Additionally, this markdown provides leaflet code for plotting the results of the index by census block group. This markdown reads census_centroids as a shapefile from my machine, as we haven't pushed this to the RDS yet. 

###RDS Pull
```{r}
library(rgeos)
library(rgdal)
library(raster)
library(tidyverse)
library(RPostgreSQL)
# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")

# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv, dbname = "dssg2018uw",
                 host = "localhost", port = 9000,
                 user = user, password = password) #local source credentials

#get reschool_programs
reschool_programs <- dbGetQuery(con, "select * from clean.reschool_summer_programs")
block_distance <- dbGetQuery(con, "select * from clean.block_distance")

#disconnect
dbDisconnect(con) 
dbUnloadDriver(drv)
```

###Establishing Cost Thresholds and Umbrella Program Types
```{r}
reschool_programs$academic <- ifelse(reschool_programs$has_academic==TRUE | reschool_programs$has_stem==TRUE,TRUE,FALSE) 

reschool_programs$art <- ifelse(reschool_programs$has_arts==TRUE | reschool_programs$has_cooking==TRUE | 
                                  reschool_programs$has_dance==TRUE | reschool_programs$has_drama==TRUE
                                | reschool_programs$has_music==TRUE,
                                TRUE,FALSE)

#cost thresolds, to be updated w/ time data from selam
reschool_programs$free <- ifelse(reschool_programs$session_cost==0,TRUE,FALSE)
reschool_programs$lowcost <- ifelse(reschool_programs$session_cost<=50,TRUE,FALSE)
reschool_programs$highcost <- ifelse(reschool_programs$session_cost>50,TRUE,FALSE)
```


###Functions for Flexible Access Index Calculation
```{r}
type <- c("academic","art") #needs to be a vector of whatever get's passed to shiny

Make_Subset <- function(dataframe,type=NULL,cost=NULL){
  dataframe$n <- 1
  if(is.null(type)){
    dataframe <- dataframe
    }
  if(length(type)==1){
    dataframe <- dataframe[dataframe[,type],]
  }
  if(length(type)>1){
    dataframe <- dataframe[apply(FUN=any,X=dataframe[,c(type)],MARGIN=1),]
  }
  if(is.null(cost)){
    return(dataframe)
  }
  else{
     dataframe <- dataframe <- dataframe[dataframe[,cost],]
  }
}


Aggregate_Subset <- function(dataframe){
  return(aggregate(n ~ session_address_1+lat+long, data=dataframe,FUN=sum))
}

Merge_Set <- function(dataframe){
  block_distance_new <- block_distance[,-c(3,4,9:14)]
  temp <- merge(block_distance_new,dataframe,all.y=TRUE)
  temp$n[is.na(temp$n)==TRUE] <- 0
  return(temp)
}

decay_fxn <- function(dataframe,mode){
  if (mode=="transit") {
    scale = 5
    column="transit_morning"
  }
  if (mode=="drive"){
    scale = 5
    column="driving_morning"
  }
  mode=mode
  dataframe[,"n"]*(ifelse(dataframe[,column]<=scale,1,(1/(dataframe[,column]/scale))^2))
}


normalize <- function(vec,max) {
  return(vec/max)
}
```

###Get total access index
This is critical to establishing a range to normalize all subset values across, as well as establishing a uniform numeric color pallete. 
```{r}
library(scales)
#User specifies query (type)

#subset dataframe by user selection
user_set <- reschool_programs

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#calculate access index per location 
merged_set$transit_morning[is.na(merged_set$transit_morning)] <- merged_set$walking_morning[is.na(merged_set$transit_morning)]
merged_set$transit_morning[merged_set$transit_morning==0] <- merged_set$walking_morning[merged_set$transit_morning==0]

merged_set$CarAccessIndex <- decay_fxn(merged_set,"drive") 
merged_set$TransitAccessIndex <- decay_fxn(merged_set,"transit") 


#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_total <- aggregate(CarAccessIndex ~ Id2,data=merged_set,FUN=sum)
max_access <- max(summary_index_total$CarAccessIndex)
summary_index_total$CarAccessIndex <- normalize(summary_index_total$CarAccessIndex,max_access)
```

###User Script for Driving
This is the exact script to use to query, for an example type.
```{r}
library(scales)
#User specifies query (type)
#type <- c("art") #"type" can include categories or cost thresholds. Pending cost per day calculations from Selam
#cost <- c("free")
type <- NULL
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type,cost)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#calculate access index per location 
merged_set$AccessIndex <- decay_fxn(merged_set,"drive") #why not apply? who knows

#get average of AccessIndex col, return to summary dataframe by blockgroup ID
summary_index_user <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum) #critical that we use sum, not mean, BECAUSE, for some specifications some program lengths will drop

#normalize
summary_index_user$AccessIndex <- normalize(summary_index_user$AccessIndex,max_access) 
```

###User Script for Transit
```{r}
library(scales)
#User specifies query (type)
#type <- c("has_sports","art")
type <- NULL #to use all
cost <- NULL

#subset dataframe by user selection
user_set <- Make_Subset(reschool_programs,type)

#aggregate dataframe by user selection
agg_set <- Aggregate_Subset(user_set)

#merge n of user selected programs to block distances dataframe
merged_set <- Merge_Set(agg_set)

#replace na and 0 transit times with drive times
merged_set$transit_morning[is.na(merged_set$transit_morning)] <- merged_set$walking_morning[is.na(merged_set$transit_morning)]
merged_set$transit_morning[merged_set$transit_morning==0] <- merged_set$walking_morning[merged_set$transit_morning==0]

#calculate access index per location, #get average of AccessIndex col, return to summary dataframe by blockgroup ID
system.time(merged_set$AccessIndex <- decay_fxn(merged_set,"transit"))
system.time(summary_index_user_transit <- aggregate(AccessIndex ~ Id2,data=merged_set,FUN=sum))

#normalize
summary_index_user_transit$AccessIndex <- normalize(summary_index_user_transit$AccessIndex,max_access)
```

###Plot Driving Summary Index
```{r}
library(leaflet)
library(RColorBrewer)

#Ordering
census_blocks$Id2 <- as.numeric(census_blocks$Id2)
merged_set$Id2 <- as.numeric(merged_set$Id2)
summary_index_user$Id2 <- as.numeric(summary_index_user$Id2)

census_blocks <- census_blocks[order(census_blocks$Id2),]
merged_set <- merged_set[order(merged_set$Id2),]
summary_index_user <- summary_index_user[order(summary_index_user$Id2),] 

#specifiying color pallet
colourCount <- length(unique(agg_set$n))
getPalette <- colorRampPalette(brewer.pal(9,"Reds"))

pal <- colorNumeric(
  palette = "Blues",
  domain =  0:1)

pal2 <- colorNumeric(
  palette = rev(getPalette(colourCount)),
  domain = range(agg_set$n))

#indicating one popup info
info <- paste("n",agg_set$n)

#creating leaflet map
Ai_driving <- leaflet(census_blocks) %>%
  addTiles() %>%
  addPolygons(color = "Blues",weight =1,smoothFactor = 0.5,opacity = 0.5,fillOpacity = 0.75,
              fillColor = ~pal(summary_index_user$AccessIndex),
              popup=paste(as.numeric(summary_index_user$Id2),summary_index_user$AccessIndex,as.numeric(census_blocks$Id2)),
              highlightOptions = highlightOptions(color = "white", weight = 0.1)) %>%
  
  addLegend(pal = pal, values = ~summary_index_user$AccessIndex, opacity = 1,title = "Driving AI Score") %>%
  
  addCircles(data = agg_set, 
             opacity = 1,weight=7, popup=info,
             color = ~pal2(agg_set$n) ) %>%
  
  setView(lat=39.7,lng=-104.9,zoom=11.5)
```

###Plot Transit Index
```{r}
library(leaflet)
library(RColorBrewer)

#Ordering
census_blocks$Id2 <- as.numeric(census_blocks$Id2)
merged_set$Id2 <- as.numeric(merged_set$Id2)
summary_index_user_transit$Id2 <- as.numeric(summary_index_user_transit$Id2)

census_blocks <- census_blocks[order(census_blocks$Id2),]
merged_set <- merged_set[order(merged_set$Id2),]
summary_index_user_transit <- summary_index_user_transit[order(summary_index_user_transit$Id2),] 

#specifiying color pallet
colourCount <- length(unique(agg_set$n))
getPalette <- colorRampPalette(brewer.pal(9,"Reds"))

pal <- colorNumeric(
  palette = "Blues",
  domain =  0:1)

pal2 <- colorNumeric(
  palette = rev(getPalette(colourCount)),
  domain = range(agg_set$n))

#indicating one popup info
info <- paste("n",agg_set$n)

#creating leaflet map
Ai_transit <- leaflet(census_blocks) %>%
  addTiles() %>%
  addPolygons(color = "Blues",weight =1,smoothFactor = 0.5,opacity = 0.5,fillOpacity = 0.75,
              fillColor = ~pal(summary_index_user_transit$AccessIndex),
              popup=paste(as.numeric(summary_index_user_transit$Id2),summary_index_user_transit$AccessIndex,as.numeric(census_blocks$Id2)),
              highlightOptions = highlightOptions(color = "white", weight = 0.1)) %>%
  
  addLegend(pal = pal, values = ~summary_index_user_transit$AccessIndex, opacity = 1,title = "Transit AI Score") %>%
  
  addCircles(data = agg_set, 
             opacity = 1,weight=7, popup=info,
             color = ~pal2(agg_set$n) ) %>%
  
  setView(lat=39.7,lng=-104.9,zoom=11.5)
```

###Diff between transit and driving
Here we check the difference between them. This is a validation test, as per the specification we're using, where both transit and driving use the same decay function with the same scale, transit should always be lower than driving, particularly in places with lots of quick access to multiple programs. 
```{r}
library(leaflet)
library(RColorBrewer)

#Ordering
census_blocks$Id2 <- as.numeric(census_blocks$Id2)
merged_set$Id2 <- as.numeric(merged_set$Id2)
summary_index_user_transit$Id2 <- as.numeric(summary_index_user_transit$Id2)

census_blocks <- census_blocks[order(census_blocks$Id2),]
merged_set <- merged_set[order(merged_set$Id2),]
summary_index_user <- summary_index_user[order(summary_index_user$Id2),] 

summary_index_user$dif <- summary_index_user$AccessIndex - summary_index_user_transit$AccessIndex

#specifiying color pallet
colourCount <- length(unique(agg_set$n))
getPalette <- colorRampPalette(brewer.pal(9,"Reds"))

pal <- colorNumeric(
  palette = "Blues",
  domain =  summary_index_total$dif)

pal2 <- colorNumeric(
  palette = rev(getPalette(colourCount)),
  domain = range(agg_set$n))

#indicating one popup info
info <- paste("n",agg_set$n)

#creating leaflet map
Ai_leaflet_dif <- leaflet(census_blocks) %>%
  addTiles() %>%
  addPolygons(color = "Blues",weight =1,smoothFactor = 0.5,opacity = 0.5,fillOpacity = 0.75,
              fillColor = ~pal(summary_index_user$dif),
              popup=paste(as.numeric(summary_index_user$Id2),summary_index_user$dif,as.numeric(census_blocks$Id2)),
              highlightOptions = highlightOptions(color = "white", weight = 0.1)) %>%
  
  addLegend(pal = pal, values = ~summary_index_user$dif, opacity = 1,title = "Dif in Access Index Score") %>%
  
  addCircles(data = agg_set, 
             opacity = 1,weight=7, popup=info,
             color = ~pal2(agg_set$n) ) %>%
  
  setView(lat=39.7,lng=-104.9,zoom=11.5)
```


