---
title: "Analysis_correlation"
author: "Haowen Zheng"
date: "8/1/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(tidyverse)
library(rgdal)
library(rgeos)
library(leaflet)
library(ggplot2)
library(tigris)
library(ggthemes)
```

## Get connected to RDS
```{r}
# install.packages("RPostgreSQL")

require("RPostgreSQL")

# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
source('/Users/luna/Desktop/DSSG/ors/other/keyforRDS')
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv, dbname = "dssg2018uw",
                 host = "localhost", port = 9000,
                 user = user, password = password)
```

## Get the data for analysis
```{r}
# get the indices
driving_index <- dbGetQuery(con, "select * from clean.driving_index")
transit_index <- dbGetQuery(con, "select * from clean.transit_index")

# get acs_demographics flat file
acs_demographics <- dbGetQuery(con, "select * from clean.acs_demographics")
# get acs_shapefile 
acs_shape <- readOGR(dsn="/Users/luna/Desktop/DSSG/ors/data/clean data/shape_census", layer="shape_census")

# get student data
students = dbGetQuery(con, "select * from clean.dps_students")
student_new <- students %>% filter(!is.na(block)) %>% left_join(student_location) #keep the students who have address info
student_bg <- student_new %>% group_by(block_group) %>% summarise(student_n = n()) #the number of students in each block group

# get neighborhood shapefile data
nbhd_shape <- readOGR(dsn="/Users/luna/dssg2018/osr_dssg2018/data/nbhd_dem_shapes", layer="nbhd_dem_shapes")
colnames(nbhd_shape@data)[1] <- "nbhd_name"
```

## Analysis
### How equal/unequal is access to out-of-school resources in Denver? Is access to osr proportional to the number of students? 

```{r}
#compare numbers of census student-age population with DPS student 
# merge the acs_demographics and student_bg together
colnames(acs_demographics)[2] <- "Id2"
analysis1 <- merge(acs_demographics, student_bg, by = "Id2")
analysis1$student_age_n <- analysis1$age_less_18 - analysis1$age_less_5

cor.test(analysis1$student_age_n, analysis1$student_n) # just checking, great that they are highly correlated
hist(analysis1$student_age_n)
hist(analysis1$student_n)

# dtk how to deal with the extreme values, see how it performs if we aggregate thing to the neighborhood level

# get relationship file
bg_nbhd <- dbGetQuery(con, "select * from clean.blockgroup_nbhds")

acs_subset <- analysis1 %>% select(Id2, student_n, student_age_n)
colnames(bg_nbhd)[3] <- "Id2"
analysis_subset <- merge(acs_subset, bg_nbhd, by = "Id2")
 # aggregate by nbhd
analysis_subset_aggregated1 <- analysis_subset %>% group_by(nbhd_name) %>% summarise(student_n_a = sum(student_n))
analysis_subset_aggregated2 <- analysis_subset %>% group_by(nbhd_name) %>% summarise(student_age_a = sum(student_age_n))

# It seems like we have three options for the student number!
head(analysis_subset_aggregated1)
summary(nbhd_shape@data$AGE_5_T) #2015estimate, acs Year5-17
summary(analysis_subset_aggregated1$student_n_a) #DPS choice students
summary(analysis_subset_aggregated2$student_age_a) #2016estimate, acs Year5-18
# We should probably use the last one as the DPS choice is biased. 

# how does the access index look like if we aggregate it on neighborhood level? 
driving_index_subset <- driving_index %>% select(Id2, AI_overall)
driving_index_subset <- merge(bg_nbhd, driving_index_subset, by = "Id2")
 # aggregate by nbhd 
driving_index_a <- driving_index_subset %>% group_by(nbhd_name) %>% summarise(AI_score = mean(AI_overall))

head(nbhd_merged_AI@data)
hist(driving_index_a$AI_score)
 # merge and plot on the map
nbhd_merged_AI <- geo_join(nbhd_shape, driving_index_a, by = "nbhd_name")
nbhd_merged_AI2 <- geo_join(nbhd_merged_AI, analysis_subset_aggregated2, by = "nbhd_name")

pal <- colorQuantile(
  palette = "Blues",
  domain = nbhd_merged_AI@data$AI_score, n = 10)
pop <- paste("Nbhd:", nbhd_merged_AI@data$nbhd_name,"<br/>",
             "AI:", nbhd_merged_AI@data$AI_score)

# map for access index on neighborhood level
leaflet(nbhd_merged_AI) %>%
  addTiles() %>%
  addPolygons(stroke = FALSE, weight = 1, smoothFactor = 0.5,
    opacity = 1.0, fillOpacity = 0.5, 
    color = ~pal(nbhd_merged_AI@data$AI_score), popup = pop) %>%
  setView(lat=39.7,lng=-104.9,zoom=10)

# let's drop the two zeros and see if Gini coefficient makes sense! 
nbhd_merged_AI_sn <- merge(driving_index_a, analysis_subset_aggregated2, by = "nbhd_name")  %>% 
  filter(student_age_a != 0)
nbhd_merged_AI_sn$AI_weighted <- nbhd_merged_AI_sn$AI_score/nbhd_merged_AI_sn$student_age_a
hist(nbhd_merged_AI_sn$AI_weighted)

library(ineq)
# Lorenz curve
plot(Lc(nbhd_merged_AI_sn$AI_weighted),col="darkred",lwd=2) 
ineq(nbhd_merged_AI_sn$AI_weighted,type="Gini")  #0.59

# to examine the data closer, let's rank the three variables
nbhd_merged_AI_sn <- nbhd_merged_AI_sn %>% 
  arrange(-AI_score) %>% 
  mutate(rank_AI = row_number()) %>% 
  arrange(-student_age_a) %>% 
  mutate(rank_student_n = row_number()) %>%
  arrange(-AI_weighted) %>% 
  mutate(rank_AI_weighted = row_number())
# This is potentially problematic because the weighted AI score ended up driven purely by the number of students in the neighborhoods.

# Therefore we change the unit of analysis to student level 
plot(Lc(nbhd_merged_AI_sn$AI_weighted, nbhd_merged_AI_sn$student_age_a),col="darkred",lwd=2) 

# map for student-age population distribution on neighborhood level
leaflet(nbhd_merged_AI2) %>%
  addTiles() %>%
  addPolygons(color = "#444444", weight = 1, smoothFactor = 0.5,
   opacity = 1.0, fillOpacity = 0.5, 
   fillColor = ~colorQuantile("YlOrRd", nbhd_merged_AI2@data$student_age_a)(nbhd_merged_AI2@data$student_age_a)) %>%
  setView(lat=39.7,lng=-104.9,zoom=10)

head(nbhd_merged_AI_sn)
```

Let's make a scatter plot showing the number of programs and access scores. 
```{r}
# driving overall index
ggplot(nbhd_merged_AI_sn, aes(student_age_a, AI_score)) +
  geom_point(aes(color= rank_AI_weighted>66)) +
  scale_color_manual(values = c("black", "red")) +
  geom_text(aes(label=ifelse(rank_AI_weighted>66,as.character(nbhd_name),'')),hjust=0.7,vjust=1, size=3) +
  xlab("Number of students in each neighborhood") +
  ylab("Access Index score") +
  theme_bw() +
  theme(legend.position="none") +
  ggtitle("Neighborhoods with low access and high student age population") 
```

We care about the following indices, AI for overall programs for driving and transit, AI for free programs for driving and transit. Therefore we want to see if there are any interesting patterns for them, too. 

```{r}
full_index <- merge(driving_index, transit_index, by = "Id2")
selected_index <- full_index %>% 
  dplyr::select(Id2, AI_overall.x, AI_overall_free.x, AI_overall.y, AI_overall_free.y) %>% # x driving, y transit 
  merge(bg_nbhd, by = "Id2")

index_agg <- selected_index %>%
    group_by(nbhd_name) %>%
    summarise_at(vars(matches("overall")), funs(mean)) %>%
    left_join(., analysis_subset_aggregated2, by = c("nbhd_name")) %>%
    mutate_at(vars(matches("overall")),funs(weighted = . / analysis_subset_aggregated2$student_age_a)) %>%
    filter(student_age_a != 0) %>%  #drop the two neighborhoods that have 0 values for number of students.
    mutate_at(vars(matches("weighted")), funs(rank = dense_rank(desc(.))))

# define the function that plots Lorenz curve
plotLC <- function(x){
  p <- plot(Lc(x, index_agg$student_age_a),col="darkred",lwd=2)
  return(p)
}

index_agg1 <- index_agg %>% dplyr::select("AI_overall.x_weighted", "AI_overall_free.x_weighted", "AI_overall.y_weighted", "AI_overall_free.y_weighted")
apply(index_agg1, 2, FUN =  plotLC) #plot

# define the scatter plot
  plotScatter <- function(var1, var2, df) {
            print(data.frame(df) %>%
            ggplot( aes(student_age_a, df[,var1])) +
            geom_point(aes(color= df[,var2]>66)) +
            scale_color_manual(values = c("black", "red")) +
            geom_text(aes(label=ifelse(df[,var2]>66,as.character(nbhd_name),'')),hjust=0.7,vjust=1, size=2) +
            xlab("Number of students in each neighborhood") +
            ylab("Access Index score") +
            theme_bw() +
            theme(legend.position="none") +
            ggtitle("Neighborhoods with low access and high student age population"))
  }
  
var_list = list(c("AI_overall.x","AI_overall.x_weighted_rank"),c("AI_overall_free.x","AI_overall_free.x_weighted_rank"),
                c("AI_overall.y","AI_overall.y_weighted_rank"),c("AI_overall_free.y","AI_overall_free.y_weighted_rank"))   

for(i in 1:length(var_list)){
  plotScatter(var1=var_list[[i]][1],var2=var_list[[i]][2],df=index_agg)
  }
```

### Leaflet maps
```{r}
nbhd_merged_AI <- geo_join(nbhd_merged_AI, index_agg, by = "nbhd_name", how = "inner")

leaflet(nbhd_merged_AI) %>%
  addTiles() %>%
  addPolygons(stroke = FALSE, weight = 1, smoothFactor = 0.5,
    opacity = 1.0, fillOpacity = 0.5, 
    color = ~pal(nbhd_merged_AI@data$AI_score), popup = pop) %>% #replace AI_score with each index
  setView(lat=39.7,lng=-104.9,zoom=10)
```

### spatial autocorrelation - Local Moran's I 
```{r}
library(spdep)
w <- poly2nb(nbhd_merged_AI, row.names=nbhd_merged_AI@data$nbhd_name) #find adjacent polygons
summary(w)
 # convert it to a spatial weights matrix
ww <-  nb2listw(w, style='B')

nbhd_merged_AI@data <- nbhd_merged_AI@data %>% mutate(Id = row_number())
oid <- order(nbhd_merged_AI$Id)
resI <- localmoran(nbhd_merged_AI$AI_score, ww)
results <- printCoefmat(data.frame(resI[oid,],row.names=nbhd_merged_AI$Id[oid]),check.names=false)
results$Id <- rownames(results)

head(results)

nbhd_merged_MI <- merge(nbhd_merged_AI, results, by = "Id")

head(nbhd_merged_MI@data)

#color by Ii (local Moran's I) if p < 0.05 (Pr.z...0.)
nbhd_merged_MI@data <- nbhd_merged_MI@data %>%
  mutate(Moran = ifelse(Pr.z...0. < 0.05, Ii, NA))

# plot the significant values (Moran's I) on the map
conpal <- colorNumeric(palette = "Blues", domain = nbhd_merged_MI@data$Moran, na.color = "grey")
leaflet(nbhd_merged_MI) %>%
  addTiles() %>%
  addPolygons(color = "#444444", weight = 1, smoothFactor = 0.5,
   opacity = 1.0, fillOpacity = 0.5, 
   fillColor = ~conpal( nbhd_merged_MI@data$Moran)) %>%
  setView(lat=39.7,lng=-104.9,zoom=10)
```

### How is access correlated with neighborhood characteristics? 
```{r}
# merge the index on block level with census block 
data <- merge(selected_index, acs_demographics, by = "Id2") %>% 
  mutate(student_age_n = age_less_18 - age_less_5) %>%
  filter(student_age_n != 0)  # drop if no students are in the block group to keep things consistent (456 bg)

# look at AI_overall first 
summary(data$AI_overall.x)

# demographics
# 1. median household income, there are 11 N.A.s so we have to drop those first
mnb1stQ <- mean(data[data$AI_overall.x < 58.57, ]$median_hh_income, na.rm = TRUE)
mnbmedian <- mean(data[data$AI_overall.x < 64.01, ]$median_hh_income, na.rm = TRUE)
mnamedian <- mean(data[data$AI_overall.x > 64.01, ]$median_hh_income, na.rm = TRUE)
mna4stQ <- mean(data[data$AI_overall.x > 68.99, ]$median_hh_income, na.rm = TRUE)
# 2. Race
# PCT_hispanic
pctH_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$pct_hispanic, na.rm = TRUE)
pctH_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$pct_hispanic, na.rm = TRUE)
pctH_amedian <- mean(data[data$AI_overall.x > 64.01, ]$pct_hispanic, na.rm = TRUE)
pctH_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$pct_hispanic, na.rm = TRUE)
# Pct_white
pctW_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$pct_white, na.rm = TRUE)
pctW_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$pct_white, na.rm = TRUE)
pctW_amedian <- mean(data[data$AI_overall.x > 64.01, ]$pct_white, na.rm = TRUE)
pctW_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$pct_white, na.rm = TRUE)
# Pct_black
pctB_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$pct_african, na.rm = TRUE)
pctB_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$pct_african, na.rm = TRUE)
pctB_amedian <- mean(data[data$AI_overall.x > 64.01, ]$pct_african, na.rm = TRUE)
pctB_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$pct_african, na.rm = TRUE)
# Pct_others
data$pct_raceOthers <- data$pct_americanindian + data$pct_asian + data$pct_pacificislander + data$pct_otherraces + data$pct_two_or_more_races

pctOthers_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$pct_raceOthers)
pctOthers_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$pct_raceOthers)
pctOthers_amedian <- mean(data[data$AI_overall.x > 64.01, ]$pct_raceOthers)
pctOthers_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$pct_raceOthers)


# 3. Pct_poverty
pctPoverty_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$poverty_pct_hh)
pctPoverty_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$poverty_pct_hh)
pctPoverty_amedian <- mean(data[data$AI_overall.x > 64.01, ]$poverty_pct_hh, na.rm = TRUE)
pctPoverty_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$poverty_pct_hh, na.rm = TRUE)
# 4. Edu
# Pct_Less than high school degrees
data$Pct_lhs <- data$less_than_hs_diploma *100/data$ttpop_25plus_edu #percentage Less than High School
pctlhs_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$Pct_lhs, na.rm = TRUE)
pctlhs_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$Pct_lhs, na.rm = TRUE)
pctlhs_amedian <- mean(data[data$AI_overall.x > 64.01, ]$Pct_lhs, na.rm = TRUE)
pctlhs_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$Pct_lhs, na.rm = TRUE)
# Pct_at least with a Bechelor's 
data$Pct_ab <- data$bachelors_or_higher_edu*100/data$ttpop_25plus_edu #percentage Above Bechalor's degree
pctab_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$Pct_ab, na.rm = TRUE)
pctab_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$Pct_ab, na.rm = TRUE)
pctab_amedian <- mean(data[data$AI_overall.x > 64.01, ]$Pct_ab, na.rm = TRUE)
pctab_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$Pct_ab, na.rm = TRUE)
# 5. Pct_native 
data$pct_native <- data$native/data$ttl_population
pctn_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$pct_native, na.rm = TRUE)
pctn_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$pct_native, na.rm = TRUE)
pctn_amedian <- mean(data[data$AI_overall.x > 64.01, ]$pct_native, na.rm = TRUE)
pctn_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$pct_native, na.rm = TRUE)
# 6. car ownership if we care about this
hist(data$pct_vehicle_own) # highly screwed, tail on the left 
pctcar_b1Q <- mean(data[data$AI_overall.x < 58.57, ]$pct_vehicle_own, na.rm = TRUE)
pctcar_bmedian <- mean(data[data$AI_overall.x < 64.01, ]$pct_vehicle_own, na.rm = TRUE)
pctcar_amedian <- mean(data[data$AI_overall.x > 64.01, ]$pct_vehicle_own, na.rm = TRUE)
pctcar_a3Q <- mean(data[data$AI_overall.x > 68.99, ]$pct_vehicle_own, na.rm = TRUE)

summary(data)
```


Graphics
``` {r}
sample_comparison <- data.frame(
  "sample" = c("Below 1st Quantile", "Below Median", "Above Median", "Above 3rd Quantile"), 
  "Ave_Median_HI" = c(mnb1stQ, mnbmedian, mnamedian, mna4stQ), 
  "PCT_Hispanic" = c(pctH_b1Q, pctH_bmedian, pctH_amedian, pctH_a3Q), 
  "PCT_White" = c(pctW_b1Q, pctW_bmedian, pctW_amedian, pctW_a3Q), 
  "PCT_Black" = c(pctB_b1Q, pctB_bmedian, pctB_amedian, pctB_a3Q),
  "PCT_Otheraces" = c(pctOthers_b1Q, pctOthers_bmedian, pctOthers_amedian, pctOthers_a3Q),
  "PCT_Poverty" = c(pctPoverty_b1Q, pctPoverty_bmedian, pctPoverty_amedian, pctPoverty_a3Q), 
  "PCT_LessThanHighSchool" = c(pctlhs_b1Q, pctlhs_bmedian, pctlhs_amedian, pctlhs_a3Q),
  "PCT_AboveBechalorDegree" = c(pctab_b1Q, pctab_bmedian, pctab_amedian, pctab_a3Q),
  "PCT_Native" = c(pctn_b1Q, pctn_bmedian, pctn_amedian, pctn_a3Q),
  "PCT_CarOwn" = c(pctcar_b1Q, pctcar_bmedian, pctcar_amedian, pctcar_a3Q))     

sample_comparison$sample <- 
  factor(sample_comparison$sample, 
         levels = c("Below 1st Quantile", "Below Median", "Above Median", "Above 3rd Quantile"))

# graph for median household income 
plot_MHI <- ggplot(sample_comparison, aes(sample, Ave_Median_HI)) +
  geom_bar(stat = "identity", fill = "#2166ac")  +
  theme_tufte()

plot_MHI

# graph for race comparison
sample_compare_race <- sample_comparison %>%
  select(sample, PCT_Hispanic, PCT_White, PCT_Black, PCT_Otheraces) %>%
  gather(race, value, -sample) 

sample_compare_race$race <- 
  factor(sample_compare_race$race, 
  levels = c("PCT_White", "PCT_Hispanic", "PCT_Otheraces", "PCT_Black"))
  
plot_race <- ggplot(sample_compare_race) +
  geom_bar(aes(sample, value, fill = race), stat = "identity", position = "dodge") +
  scale_fill_manual(values=c("#2166ac", "#b2182b", "#fd8d3c", "#78c679")) +
  xlab("") + 
  theme_bw()

# graph for ses comparison, percentage of levels of education, and poverty 
sample_compare_ses <- sample_comparison %>% 
  select(sample, PCT_LessThanHighSchool, PCT_AboveBechalorDegree, PCT_Poverty) %>%
  gather(ses, value, -sample) 
sample_compare_ses$ses <-
  factor(sample_compare_ses$ses,
  levels = c("PCT_LessThanHighSchool", "PCT_AboveBechalorDegree", "PCT_Poverty"))
plot_edu_poverty <- 
  ggplot(sample_compare_ses) +
  geom_bar(aes(sample, value, fill = ses), stat = "identity", position = "dodge") +
  xlab("") +
  theme_bw()

# graph for percentage of native people
plot_native <- ggplot(sample_comparison, aes(sample, PCT_Native)) +
  geom_bar(stat = "identity", position = "dodge")

plot_native
```

``` {r}
# graph for percentage of households that have car(s)
plot_car1 <- ggplot(sample_comparison, aes(sample, PCT_CarOwn)) +
  geom_bar(stat = "identity", position = "dodge") #maybe it makes more sense to compare the car ownership accross transit index?                                                   #see if there are places where people really need public transit but score low
  # 1st Q, 2nd Q, 3rd Q, 4th Q
  car1 <- mean(data[data$AI_overall.y < 5.58, ]$pct_vehicle_own, na.rm = TRUE)
  car2 <- mean(data[data$AI_overall.y < 7.86 & data$AI_overall.y >= 5.58, ]$pct_vehicle_own, na.rm = TRUE)
  car3 <- mean(data[data$AI_overall.y < 10.75 & data$AI_overall.y >= 7.86, ]$pct_vehicle_own, na.rm = TRUE)
  car4 <- mean(data[data$AI_overall.y > 10.75, ]$pct_vehicle_own, na.rm = TRUE)

  sample_comparison_transit <- data.frame(
  "sample" = c("1st Quantile", "2nd Quantile", "3rd Quantile", "4th Quantile"), 
  "Pct_car" = c(car1, car2, car3, car4))
  
  sample_comparison_transit$sample <- 
  factor(sample_comparison_transit$sample, 
         levels = c("1st Quantile", "2nd Quantile", "3rd Quantile", "4th Quantile"))

  plot_car2 <- ggplot(sample_comparison_transit, aes(sample, Pct_car)) +
    geom_bar(stat = "identity", position = "dodge")
  plot_car2 #not particularly interesting
  
  # let's pull out the leaflet map of car ownership again 
  leaflet(census_shape) %>%
  addTiles() %>%
  addPolygons(color = "#444444", weight = 1, smoothFactor = 0.5,
    opacity = 1.0, fillOpacity = 0.5, popup = info2,
    fillColor = ~colorFactor(colors5, census_shape@data$PCT_Vhcl_w)(census_shape@data$PCT_Vhcl_w))
  
  # Okay last try. This time see if there is any patterns if we avarage over low vs. high car ownership rates
  summary(data$pct_vehicle_own)
  # really low (below 1st Q) vs. really high(above 3rd Q)
  score1 <- mean(data[data$pct_vehicle_own < 86.31, ]$AI_overall.y, na.rm = TRUE)
  score2 <- mean(data[data$pct_vehicle_own > 98.37, ]$AI_overall.y, na.rm = TRUE)
```

Other stuff that could be of potential interest
```{r}
# ses and free programs 


# or just averaging the index score for different groups? 
 # first aggregate the number of students to a block group level 


```


Mann-Whitney U Tests
```{r}
head(data)

# Ai_overall_x low access
subset1 <- data %>% filter(AI_overall.x < 58.57) 
# Ai_overall_x high access
subset2 <- data %>% filter(AI_overall.x > 68.99)

# median household income
wilcox.test(subset1$median_hh_income, subset2$median_hh_income) #significant at p = 0.04024
# t.test(subset1$median_hh_income, subset2$median_hh_income) 
 #shouldn't use t test cause data is skewed

# race
wilcox.test(subset1$pct_white, subset2$pct_white) #rejects null
wilcox.test(subset1$pct_african, subset2$pct_african) #rejects null
wilcox.test(subset1$pct_hispanic, subset2$pct_hispanic) #rejects null 
wilcox.test(subset1$pct_raceOthers, subset2$pct_raceOthers) #rejects null 
# native
wilcox.test(subset1$pct_native, subset2$pct_native) #rejects null 
# car ownership
wilcox.test(subset1$pct_vehicle_own, subset2$pct_vehicle_own) # can't reject null; distributions look exactly the same
# education
wilcox.test(subset1$Pct_ab, subset2$Pct_ab) #rejects null 
wilcox.test(subset1$Pct_lhs, subset2$Pct_lhs) #rejects null 
# poverty
wilcox.test(subset1$poverty_pct_hh, subset2$poverty_pct_hh) #couldn't reject null

```

How is access correlated with student characteristics? 

RACE
```{r}
head(student_bg) # number of students in each block group 
head(student_new) # each row being a student
head(selected_index) # indices for all & free programs 
head(student_DPS_bg) # aggregate to block group levels

student_DPS_bg <- dbGetQuery(con, "select * from shiny.dps_student_aggregate_bgs")
student_DPS_bg$perc_otheraces_students <- 
  100 - student_DPS_bg$perc_hispanic_students - student_DPS_bg$perc_black_students - student_DPS_bg$perc_white_students
# Because the numbers were rounded up, we got 4 values that are negative. Change them to zeros. 
student_DPS_bg$perc_otheraces_students <- ifelse(
  student_DPS_bg$perc_otheraces_students < 0, 0, student_DPS_bg$perc_otheraces_students )

# merge
colnames(student_DPS_bg)[1] <- "Id2"
student_DPS_bg <- merge(student_DPS_bg, selected_index, by = "Id2")

# Does racial composition change if we use DPS data?
# get the variables
# hispanic
hispanic1 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x < 58.57, ]$perc_hispanic_students, na.rm = TRUE)
hispanic2 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x < 64.01, ]$perc_hispanic_students, na.rm = TRUE)
hispanic3 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x > 64.01, ]$perc_hispanic_students, na.rm = TRUE)
hispanic4 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x > 68.99, ]$perc_hispanic_students, na.rm = TRUE)
# white 
white1 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x < 58.57, ]$perc_white_students, na.rm = TRUE)
white2 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x < 64.01, ]$perc_white_students, na.rm = TRUE)
white3 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x > 64.01, ]$perc_white_students, na.rm = TRUE)
white4 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x > 68.99, ]$perc_white_students, na.rm = TRUE)
# black
black1 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x < 58.57, ]$perc_black_students, na.rm = TRUE)
black2 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x < 64.01, ]$perc_black_students, na.rm = TRUE)
black3 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x > 64.01, ]$perc_black_students, na.rm = TRUE)
black4 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x > 68.99, ]$perc_black_students, na.rm = TRUE)
# others
others1 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x < 58.57, ]$perc_otheraces_students, na.rm = TRUE)
others2 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x < 64.01, ]$perc_otheraces_students, na.rm = TRUE)
others3 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x > 64.01, ]$perc_otheraces_students, na.rm = TRUE)
others4 <- mean(student_DPS_bg[student_DPS_bg$AI_overall.x > 68.99, ]$perc_otheraces_students, na.rm = TRUE)


# make the data frame
student_comparison <- data.frame(
  "sample" = c("Low", "Below median", "Above median", "High"),
  "Hispanic" = c(hispanic1, hispanic2, hispanic3, hispanic4),
  "White" = c(white1, white2, white3, white4),
  "Black" = c(black1, black2, black3, black4),
  "Others" = c(others1, others2, others3, others4)
)
student_comparison$sample <- factor(student_comparison$sample, 
                                       levels = c("Low", "Below Median", "Above Median", "High"))

# transform the dataset 
plotdata <- student_comparison %>% 
  gather(Race, value, -sample) 
plotdata$Race <- factor(plotdata$Race, 
                        levels = c("Hispanic", "White", "Black", "Others"))

# make the graph 
ggplot(plotdata, aes(sample, value, fill = Race)) +
  geom_bar(stat = "identity", position = "dodge") +
  xlab(" ") +
  ylab("Percentages") +
  ggtitle("Racial Compostion for Areas with Different Levels of Access to OSR") +
  scale_fill_discrete(name="Race and Ethnicity") +
  scale_fill_manual(values=c("#2b8cbe", "#fb6a4a", "#fecc5c", "#78c679")) +
  theme_tufte()

```



## Close the link when you are done.
```{r}
dbDisconnect(con) 
dbUnloadDriver(drv)
```
